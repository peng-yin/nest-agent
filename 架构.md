# 架构设计

## 1. 整体架构

```mermaid
graph TB
    subgraph Client["客户端"]
        FE["前端 (public/index.html)<br/>SSE 客户端 + AG-UI 事件解析"]
    end

    subgraph NestJS["NestJS 应用层"]
        direction TB

        subgraph Controllers["Controller 层"]
            AC["AuthController<br/>/api/v1/auth"]
            CC["ChatController<br/>/api/v1/chat"]
            WC["WorkflowController<br/>/api/v1/workflows"]
            RC["RagController<br/>/api/v1/rag"]
        end

        subgraph Services["Service 层"]
            AS["AuthService<br/>bcrypt + JWT"]
            CS["ChatService<br/>消息持久化 + 记忆策略"]
            WS["WorkflowService<br/>工作流 CRUD"]
            RS["RagService<br/>分块 + Embedding + 检索"]
        end

        subgraph Core["Agent 核心"]
            OS["AgentService<br/>编排入口"]
            SF["SupervisorFactory<br/>多 Agent 协同"]
            DE["DagEngine<br/>DAG 执行引擎"]
        end

        subgraph Infra["基础设施"]
            LLM["LLMService<br/>多供应商工厂"]
            TR["ToolRegistry<br/>工具注册中心"]
            MS["MilvusService<br/>向量数据库封装"]
            RDS["RedisService<br/>缓存服务"]
        end
    end

    subgraph Storage["存储层"]
        MySQL["MySQL 8.0<br/>持久化存储"]
        Redis["Redis 7<br/>缓存 / 会话"]
        Milvus["Milvus 2.3<br/>向量检索"]
    end

    subgraph External["外部服务"]
        OpenAI["OpenAI API"]
        Anthropic["Anthropic API"]
        DashScope["DashScope API"]
        Tavily["Tavily Search API"]
    end

    FE -->|"HTTP POST + SSE 流"| CC
    FE -->|"HTTP"| AC
    FE -->|"HTTP"| WC
    FE -->|"HTTP"| RC

    AC --> AS
    CC --> CS
    WC --> WS
    RC --> RS

    CS --> OS
    OS --> SF
    OS --> DE
    SF --> LLM
    DE --> LLM
    SF --> TR
    DE --> TR
    RS --> MS

    LLM --> OpenAI
    LLM --> Anthropic
    LLM --> DashScope
    TR --> Tavily
    TR --> MS

    AS --> MySQL
    CS --> MySQL
    CS --> RDS
    WS --> MySQL
    RS --> MySQL
    RDS --> Redis
    MS --> Milvus
```

---

## 2. 一次对话请求的完整流程

以用户发送「搜索一下 NestJS 11 有什么新功能」为例：

```mermaid
sequenceDiagram
    actor User as 用户浏览器
    participant CC as ChatController
    participant CS as ChatService
    participant OS as AgentService
    participant SF as SupervisorFactory
    participant Agent as researcher Agent
    participant Tool as web_search
    participant LLM as LLM Service

    User->>CC: POST /chat/completions { message: "搜索..." }

    rect rgb(240, 248, 255)
        Note over CC: 请求处理阶段
        CC->>CC: ① Zod 校验请求体
        CC->>CS: ② 获取/创建 Conversation
        CC->>CS: ③ 保存 user 消息到 DB
        CC->>CS: ④ 读取上下文消息 (窗口+摘要)
        CC->>User: ⑤ 设置 SSE 响应头
    end

    CC->>OS: ⑥ agentService.execute()
    OS-->>User: event: RUN_STARTED

    rect rgb(255, 248, 240)
        Note over OS,SF: Supervisor 路由阶段
        OS->>SF: 没有 workflowId → Supervisor 模式
        SF->>LLM: 结构化输出: "这个问题需要搜索"
        LLM-->>SF: { next: "researcher" }
        SF-->>User: event: STEP_STARTED (researcher)
    end

    rect rgb(240, 255, 240)
        Note over Agent,Tool: Agent 执行阶段
        Agent->>LLM: 分析用户意图
        LLM-->>Agent: 决定调用 web_search
        Agent-->>User: event: TOOL_CALL_START (web_search)
        Agent-->>User: event: TOOL_CALL_ARGS { query: "NestJS 11" }
        Agent->>Tool: invoke web_search
        Tool-->>Agent: Tavily 搜索结果
        Agent-->>User: event: TOOL_CALL_END
    end

    rect rgb(248, 240, 255)
        Note over Agent,LLM: 生成回答阶段
        Agent->>LLM: 根据搜索结果生成回答
        LLM-->>Agent: 流式生成文本
        Agent-->>User: event: TEXT_MESSAGE_START
        Agent-->>User: event: TEXT_MESSAGE_CONTENT (流式 delta)
        Agent-->>User: event: TEXT_MESSAGE_END
        Agent-->>User: event: STEP_FINISHED
    end

    OS-->>User: event: RUN_FINISHED

    rect rgb(245, 245, 245)
        Note over CC,CS: 收尾阶段
        CC->>CS: ⑦ 收集 assistant 消息
        CC->>CS: ⑧ 持久化到 DB
        CC->>User: ⑨ event: done / data: [DONE]
    end
```

---

## 3. 两种编排模式

### 3.1 Supervisor 模式（默认）

**适用场景：** 不指定 workflowId 时自动使用。LLM 充当「主管」动态路由到不同 Agent。

```mermaid
graph TD
    Start((开始)) --> Supervisor

    subgraph Loop["Supervisor 循环 (最多25轮)"]
        Supervisor["Supervisor<br/>LLM 结构化路由<br/>输出: { next: agent_name }"]
        Researcher["researcher Agent<br/>搜索 + RAG 检索"]
        Responder["responder Agent<br/>直接回答"]

        Supervisor -->|"next = researcher"| Researcher
        Supervisor -->|"next = responder"| Responder
        Researcher -->|"执行完毕"| Supervisor
        Responder -->|"执行完毕"| Supervisor
    end

    Supervisor -->|"next = __end__"| End((结束))
```

**工作原理：**

1. Supervisor 是一个带结构化输出的 LLM 节点
2. 输出 schema: `{ next: "researcher" | "responder" | "__end__" }`
3. 路由到目标 Agent 执行，执行完自动回到 Supervisor
4. Supervisor 判断「任务完成」→ 路由到 `__end__`
5. 递归上限 25 次，防止死循环

**代码路径：**
- `supervisor.factory.ts` — 构建 Supervisor 有向图
- `agent.service.ts → executeSupervisor()` — 执行并发射事件

### 3.2 DAG 模式（自定义工作流）

**适用场景：** 指定 workflowId 时使用。用户预定义的有向无环图。

```mermaid
graph TD
    S["start<br/>入口标记"] --> A1["agent-1 (研究员)<br/>createReactAgent"]
    A1 --> C{"condition<br/>关键词匹配"}
    C -->|"内容包含 A"| A2["agent-2 (写手)<br/>createReactAgent"]
    C -->|"内容包含 B"| T1["tool-1 (搜索)<br/>直接调用工具"]
    A2 --> E["end<br/>出口标记"]
    T1 --> E

    style S fill:#e1f5fe
    style E fill:#e8f5e9
    style C fill:#fff3e0
```

**节点类型：**

| 类型 | 执行方式 | 说明 |
|------|---------|------|
| `start` | 不执行 | 入口标记，DAG 起点 |
| `end` | 不执行 | 出口标记，DAG 终点 |
| `agent` | `createReactAgent(llm, tools, prompt)` | 可调用工具的 AI Agent |
| `tool` | 直接 `tool.invoke()` | 调用指定工具，输出追加到消息链 |
| `condition` | 关键词匹配 | 读取最后一条消息，匹配关键词路由到不同分支 |

**代码路径：**
- `dag-engine.ts` — 编译 nodes/edges 为 LangGraph StateGraph
- `agent.service.ts → executeDag()` — 执行并发射事件

---

## 4. 记忆管理策略

ChatService 实现了**滑动窗口 + LLM 自动摘要**的混合记忆管理：

```mermaid
flowchart TD
    A["获取会话消息"] --> B{"消息总数 ≤ windowSize (10)?"}
    B -->|是| C["直接返回全部消息"]
    B -->|否| D{"消息总数 > summaryThreshold (20)?"}
    D -->|否| E["取最近 windowSize 条消息"]
    D -->|是| F["调 LLM 对早期消息生成摘要"]
    F --> G["摘要存入 conversation.summary"]
    G --> H["返回: [摘要作为 system 消息]<br/>+ 最近 windowSize 条消息"]

    style C fill:#e8f5e9
    style E fill:#e8f5e9
    style H fill:#e8f5e9
```

**缓存策略：**
- 会话消息缓存在 Redis，TTL 3600 秒
- key 格式: `conv:{conversationId}:msgs`
- 新消息追加到缓存末尾（不全量重写）

---

## 5. LLM 多供应商抽象

```mermaid
graph LR
    Factory["LLMService.createModel()"] --> Check{"provider?"}

    Check -->|"openai"| OAI["ChatOpenAI<br/>model: gpt-4o<br/>支持 baseUrl 自定义"]
    Check -->|"anthropic"| ANT["ChatAnthropic<br/>model: claude-sonnet"]
    Check -->|"dashscope"| DS["ChatOpenAI<br/>model: qwen-max<br/>baseURL: dashscope API"]

    OAI --> Compatible["兼容 OpenAI API 的任意服务<br/>SiliconFlow / Deepseek / vLLM 等<br/>通过 OPENAI_BASE_URL 接入"]

    style Factory fill:#e3f2fd
    style Compatible fill:#fff9c4
```

---

## 6. 工具系统

```mermaid
graph TB
    TR["ToolRegistry<br/>(全局单例)"]

    TR --> WS["web_search"]
    TR --> RR["rag_retrieval"]

    subgraph web_search["web_search 工具"]
        WS_IN["输入: { query, maxResults? }"]
        WS_IMPL["实现: Tavily API"]
        WS_OUT["输出: 标题 + URL + 摘要"]
    end

    subgraph rag_retrieval["rag_retrieval 工具"]
        RR_IN["输入: { query, topK?, knowledgeBaseId? }"]
        RR_IMPL["实现: Milvus 向量检索"]
        RR_OUT["输出: 相似文档片段列表"]
    end

    Agent["createReactAgent<br/>声明可用工具"] -.->|"LLM 自主决定<br/>何时调用"| TR
```

---

## 7. RAG 知识库流水线

```mermaid
graph TD
    subgraph Ingest["文档入库流程"]
        direction TB
        Upload["用户上传文档"] --> Split["RecursiveCharacterTextSplitter<br/>chunkSize=1000, overlap=200"]
        Split --> Embed["OpenAI Embeddings<br/>text-embedding-3-small"]
        Embed --> Store["Milvus 向量写入<br/>collection 按 tenant 隔离"]
    end

    subgraph Query["查询检索流程"]
        direction TB
        Q["用户 query"] --> QE["query → embedding"]
        QE --> Search["Milvus ANN 检索"]
        Search --> TopK["返回 Top-K 结果"]
    end

    Store -.->|"存储向量"| Search

    style Upload fill:#e3f2fd
    style TopK fill:#e8f5e9
```

---

## 8. 认证与多租户

```mermaid
flowchart TD
    Req["请求进入"] --> JWT["JwtAuthGuard"]

    JWT -->|"解析 Bearer Token<br/>验证签名 + 过期时间"| InjectUser["注入 request.user<br/>{ id, email, tenantId, role }"]

    InjectUser --> Tenant["TenantGuard"]
    Tenant -->|"校验 tenantId 存在"| InjectTenant["注入 request.query.tenantId"]

    InjectTenant --> Controller["Controller"]
    Controller -->|"@CurrentUser() → 用户对象<br/>@TenantId() → 租户 ID"| Service["Service 层"]
    Service -->|"所有查询带 tenantId<br/>数据天然隔离"| DB[(MySQL)]

    style JWT fill:#ffebee
    style Tenant fill:#fff3e0
    style Controller fill:#e8f5e9
```

---

## 9. AG-UI 事件流协议

系统使用 AG-UI (Agent User Interaction) 协议通过 SSE 推送事件：

```mermaid
stateDiagram-v2
    [*] --> RUN_STARTED: 编排开始

    RUN_STARTED --> STEP_STARTED: Agent 开始执行
    STEP_STARTED --> TOOL_CALL_START: Agent 调用工具
    TOOL_CALL_START --> TOOL_CALL_ARGS: 流式推送工具参数
    TOOL_CALL_ARGS --> TOOL_CALL_END: 工具调用完成
    TOOL_CALL_END --> TOOL_CALL_RESULT: 工具返回结果

    STEP_STARTED --> TEXT_MESSAGE_START: Agent 生成文本
    TEXT_MESSAGE_START --> TEXT_MESSAGE_CONTENT: 流式推送文本
    TEXT_MESSAGE_CONTENT --> TEXT_MESSAGE_CONTENT: 持续推送
    TEXT_MESSAGE_CONTENT --> TEXT_MESSAGE_END: 文本结束

    TOOL_CALL_RESULT --> STEP_FINISHED: 步骤完成
    TEXT_MESSAGE_END --> STEP_FINISHED: 步骤完成

    STEP_FINISHED --> STEP_STARTED: 下一个 Agent
    STEP_FINISHED --> RUN_FINISHED: 编排结束

    RUN_FINISHED --> [*]
```

---

## 10. 目录结构

```
src/
├── main.ts                          # 启动入口
├── app.module.ts                    # 根模块
│
├── auth/                            # 认证模块
│   ├── auth.controller.ts           # 登录/注册接口
│   ├── auth.service.ts              # bcrypt + JWT
│   ├── auth.module.ts
│   ├── jwt.strategy.ts              # Passport JWT 策略 + 类型定义
│   └── guards.ts                    # JwtAuthGuard + TenantGuard
│
├── chat/                            # 对话模块
│   ├── chat.controller.ts           # SSE 流式接口 + 会话 CRUD
│   ├── chat.service.ts              # 消息持久化 + 记忆策略
│   └── chat.module.ts
│
├── agent/                           # Agent 模块（核心）
│   ├── agent.service.ts             # 编排入口，Supervisor/DAG 二选一
│   ├── agent.module.ts
│   ├── supervisor.factory.ts        # Supervisor 有向图构建
│   ├── dag-engine.ts                # DAG 编译执行引擎
│   ├── workflow.controller.ts       # 工作流 CRUD 接口
│   └── workflow.service.ts          # 工作流持久化
│
├── rag/                             # RAG 模块
│   ├── rag.controller.ts            # 知识库 CRUD + 检索接口
│   ├── rag.service.ts               # 分块 + Embedding + 检索
│   ├── rag.module.ts
│   └── milvus.service.ts            # Milvus 向量数据库封装
│
├── llm/                             # LLM 模块
│   ├── llm.service.ts               # 多供应商工厂
│   └── llm.module.ts
│
├── tools/                           # 工具模块
│   ├── tool-registry.ts             # 工具注册中心
│   ├── web-search.tool.ts           # 网页搜索工具
│   ├── rag-retrieval.tool.ts        # RAG 检索工具
│   └── tools.module.ts
│
├── redis/                           # Redis 模块
│   ├── redis.service.ts
│   ├── redis.module.ts
│   └── redis.constants.ts
│
├── entities/                        # TypeORM 实体
│   ├── user.entity.ts
│   ├── conversation.entity.ts
│   ├── message.entity.ts
│   ├── workflow.entity.ts
│   ├── knowledge-base.entity.ts
│   └── index.ts
│
└── common/                          # 公共模块
    ├── config/configuration.ts      # 配置定义
    ├── filters/global-exception.filter.ts
    ├── interfaces/ag-ui-events.ts   # AG-UI 协议事件定义
    └── decorators/                  # 自定义装饰器
        ├── current-user.decorator.ts
        └── tenant.decorator.ts
```
